include "math"
include "string"
include "iwbtg/src/globals"
include "iwbtg/src/level"
include "output"


define ZERO_CHAR 48  // '0'
define TIME_SCALE 100


fn update_kid_animation_data(anim_data) {
    let new_anim_ss = get(anim_data)
    if new_anim_ss == kid_anim_ss {
        return -1
    }
    kid_anim_ss = get(anim_data)
    kid_anim_frames = get(anim_data+1)
    kid_anim_frame_interval = get(anim_data+2)
}


fn copy_kid_pixels() {
    let kid_pixel_x = kid_x / COORD_SCALE
    let kid_pixel_y = kid_y / COORD_SCALE

    copy_screen_region(
        kid_pixel_buffer,
        kid_pixel_x, kid_pixel_y,
        KID_PIXEL_WIDTH, KID_PIXEL_HEIGHT
    )
}


fn paste_kid_pixels() {
    let kid_pixel_x = kid_x / COORD_SCALE
    let kid_pixel_y = kid_y / COORD_SCALE

    paste_screen_region(
        kid_pixel_buffer,
        kid_pixel_x, kid_pixel_y,
        KID_PIXEL_WIDTH, KID_PIXEL_HEIGHT
    )
}


fn kid_death() {
    copy_kid_pixels()
    paste_kid_pixels()

    kid_is_dead = true
    let kid_center_x = kid_x + KID_WIDTH / 2
    let kid_center_y = kid_y + KID_HEIGHT / 2

    for (let i = 0; i < BLOOD_PARTICLE_COUNT; i = i + 1) {
        set(blood_particles_x+i, kid_center_x)
        set(blood_particles_y+i, kid_center_y)
        let vx = next_rand() % (BLOOD_PARTICLE_VX * 2) - BLOOD_PARTICLE_VX
        let vy = next_rand() % BLOOD_PARTICLE_VY
        set(blood_particles_vx+i, vx)
        set(blood_particles_vy+i, vy)
    }

    death_text_timer = 500
}


fn blood_particles_tick() {
    for (let i = 0; i < BLOOD_PARTICLE_COUNT; i = i + 1) {
        let x = get(blood_particles_x+i)
        if x == -1 {
            continue
        }

        let color = next_rand() % BLOOD_COLOR_VAR - (BLOOD_COLOR_VAR / 2) + BLOOD_COLOR
        color(color, 0, 0)

        let y = get(blood_particles_y+i)
        let vx = get(blood_particles_vx+i)
        let vy = get(blood_particles_vy+i)

        let new_vy = vy + BLOOD_PARTICLE_GRAVITY
        let new_x = x + vx * DELTA
        let new_y = y + vy * DELTA

        if (new_x < 0) + (new_x > WIDTH*COORD_SCALE) + (new_y > HEIGHT*COORD_SCALE + 10000) {
            // Delete particle
            set(blood_particles_x+i, -1)
            continue
        }
        set(blood_particles_x+i, new_x)
        set(blood_particles_y+i, new_y)
        set(blood_particles_vy+i, new_vy)

        rect(
            new_x / COORD_SCALE, new_y / COORD_SCALE, 
            BLOOD_PARTICLE_SIZE, BLOOD_PARTICLE_SIZE
        )
        
        // Draw more rects in between the previous and current one to fill in gaps.
        let diff_x = new_x - x
        let diff_y = new_y - y
        let dist_x = abs(diff_x)
        let dist_y = abs(diff_y)
        let dist = dist_x + dist_y
        let between_rects = dist / 1500
        let shift_x, shift_y
        if !between_rects {
            continue
        }
        shift_x = diff_x / between_rects
        shift_y = diff_y / between_rects
        for (let j = 0; j < between_rects; j = j + 1) {
            let between_x = x + shift_x * j
            let between_y = y + shift_y * j
            rect(
                between_x / COORD_SCALE, between_y / COORD_SCALE, 
                BLOOD_PARTICLE_SIZE, BLOOD_PARTICLE_SIZE
            )
        }
    }
}


fn draw_death_text() {
    let death_text_1 = "YOU DIED"
    let death_text_2 = "Press ENTER to Restart"

    draw_shadow_text(death_text_1, 320, 100, 3, TEXT_ALIGN_CENTER, 3)
    draw_shadow_text(death_text_2, 320, 150, 2, TEXT_ALIGN_CENTER, 2)
}


fn collide_kid(do_x_collision) {
    let level_data_pointer = get(levels_list+current_level)
    level_data_pointer = level_data_pointer + LEVEL_OBJ_COUNT_INDEX
    let level_object_count = get(level_data_pointer)
    level_data_pointer = level_data_pointer + 1

    let ground_collision_occurred = false

    for (let i = 0; i < level_object_count; i = i + 1) {
        let obj_id = get(obj_id_array+i)
        let obj_x = get(obj_x_array+i)
        let obj_y = get(obj_y_array+i)
        let obj_width = get(obj_width_array+i)
        let obj_height = get(obj_height_array+i)

        // Adjust hitbox for spikes
        let is_spike = obj_id < 4
        if is_spike {
            let half_tile = TILE_SIZE * COORD_SCALE / 2
            if obj_id == 0 {
                obj_y = obj_y + half_tile
                obj_height = obj_height - half_tile
                obj_x = obj_x + SPIKE_HITBOX_MOD
                obj_width = obj_width - SPIKE_HITBOX_MOD * 2
            }
            else if obj_id == 1 {
                obj_width = obj_width - half_tile
                obj_y = obj_y + SPIKE_HITBOX_MOD
                obj_height = obj_height - SPIKE_HITBOX_MOD * 2
            }
            else if obj_id == 2 {
                obj_height = obj_height - half_tile
                obj_x = obj_x + SPIKE_HITBOX_MOD
                obj_width = obj_width - SPIKE_HITBOX_MOD * 2
            }
            else {
                obj_x = obj_x + half_tile
                obj_width = obj_width - half_tile
                obj_y = obj_y + SPIKE_HITBOX_MOD
                obj_height = obj_height - SPIKE_HITBOX_MOD * 2
            }

            if debug_mode_enabled {
                color(255, 0, 0)
                outline_rect(obj_x / COORD_SCALE, obj_y / COORD_SCALE, obj_width / COORD_SCALE, obj_height / COORD_SCALE)
            }
        }

        if (obj_x < kid_x + KID_WIDTH) * (kid_x < obj_x + obj_width) *
            (obj_y < kid_y + KID_HEIGHT) * (kid_y < obj_y + obj_height) {
            
            // Hit spike
            if is_spike {
                kid_death()
                break
            }

            // Handle x collision
            if do_x_collision {
                if kid_vx > 0 {
                    kid_x = obj_x - KID_WIDTH
                }
                else {
                    kid_x = obj_x + obj_width
                }
            }
            // Handle y collision
            else {
                if kid_vy > 0 {
                    kid_y = obj_y - KID_HEIGHT
                    ground_collision_occurred = true
                    kid_has_double_jump = true
                    kid_is_grounded = true
                }
                else {
                    kid_y = obj_y + obj_height
                    kid_jump_counter = 0
                }
                kid_vy = 0
            }
            break
        }

        level_data_pointer = level_data_pointer + 5
    }

    kid_has_jump = ground_collision_occurred
}


fn move_kid() {
    // Handle jump
    if !prev_A * A * !kid_jump_counter {
        if kid_has_jump {
            kid_jump_counter = KID_JUMP_TIME
            kid_has_jump = false
        }
        else if kid_has_double_jump {
            kid_jump_counter = KID_DOUBLE_JUMP_TIME
            kid_has_double_jump = false
        }
    }
    let prev_A = A

    if kid_jump_counter {
        kid_jump_counter = kid_jump_counter - DELTA
        kid_jump_counter = kid_jump_counter * (kid_jump_counter > 0)  // Set to 0 if negative
        let progress_divisor = KID_JUMP_TIME * kid_has_double_jump + KID_DOUBLE_JUMP_TIME * !kid_has_double_jump
        let jump_progress = kid_jump_counter * 100 / progress_divisor
        kid_vy = jump_progress * -KID_JUMP_STRENGTH
        if !A {
            kid_jump_counter = 0
            if kid_vy < KID_JUMP_CUTOFF_VY {
                kid_vy = KID_JUMP_CUTOFF_VY
            }
        }
    }

    // Horizontal movement
    if LEFT + RIGHT {
        kid_facing_left = LEFT + !RIGHT
        next_rand()  // Seed RNG with player movement
    }
    kid_vx = -KID_SPEED * LEFT + KID_SPEED * RIGHT
    kid_x = kid_x + kid_vx * DELTA
    collide_kid(true)

    // Vertical movement
    kid_vy = kid_vy + KID_GRAVITY
    kid_vy = (kid_vy < KID_MAX_VY) * kid_vy + (kid_vy >= KID_MAX_VY) * KID_MAX_VY  // Clamp velocity
    kid_y = kid_y + kid_vy * DELTA

    kid_is_grounded = false
    collide_kid(false)

    // Handle animations
    let new_anim = ANIM_KID_IDLE
    if !kid_is_grounded {
        if kid_jump_counter {
            new_anim = ANIM_KID_JUMP
        }
        else {
            new_anim = ANIM_KID_FALL
        }
    }
    else if kid_vx {
        new_anim = ANIM_KID_WALK
    }
    update_kid_animation_data(new_anim)
}


fn set_kid_checkpoint(obj_x, obj_y) {
    kid_save_x = kid_x
    kid_save_y = kid_y
    kid_save_level = current_level

    hit_save_block_x = obj_x / (COORD_SCALE * TILE_SIZE)
    hit_save_block_y = obj_y / (COORD_SCALE * TILE_SIZE)
    hit_save_block_timer = SAVE_BLOCK_HIT_SPRITE_DURATION

    draw_level_object(SAVE_BLOCK_HIT_ID, hit_save_block_x, hit_save_block_y, 1, 1)
}


fn shoot_bullet_tick() {
    if !prev_B * B * (bullet_count < MAX_BULLETS) {
        // Find open slot
        let new_bullet_direction = -2 * !(!kid_facing_left) + 1

        let KID_CENTER_X = kid_x + KID_WIDTH / 2
        let KID_CENTER_Y = kid_y + KID_HEIGHT / 2
        let bullet_x = KID_CENTER_X + 16000 * new_bullet_direction

        for (let i = 0; i < MAX_BULLETS; i = i + 1) {
            let bullet_dir = get(bullet_directions+i)
            if bullet_dir == 0 {
                set(bullet_directions+i, new_bullet_direction)
                set(bullet_positions_x+i, bullet_x)
                set(bullet_positions_y+i, KID_CENTER_Y)
                let pixel_buffer_pointer = bullet_pixel_buffer + i * BULLET_PIXEL_SIZE * BULLET_PIXEL_SIZE
                copy_screen_region(
                    pixel_buffer_pointer,
                    bullet_x / COORD_SCALE, KID_CENTER_Y / COORD_SCALE,
                    BULLET_PIXEL_SIZE, BULLET_PIXEL_SIZE
                )
                break
            }
        }
        bullet_count = bullet_count + 1
    }
    let prev_B = B
}


fn collide_bullet(bullet_index, bullet_x, bullet_y) {
    let level_data_pointer = get(levels_list+current_level)
    level_data_pointer = level_data_pointer + LEVEL_OBJ_COUNT_INDEX
    let level_object_count = get(level_data_pointer)
    level_data_pointer = level_data_pointer + 1
    
    for (let i = 0; i < level_object_count; i = i + 1) {
        let obj_id = get(obj_id_array+i)
        let obj_x = get(obj_x_array+i)
        let obj_y = get(obj_y_array+i)
        let obj_width = get(obj_width_array+i)
        let obj_height = get(obj_height_array+i)
        
        if (bullet_x > obj_x) * (bullet_x < obj_x + obj_width) *
            (bullet_y > obj_y) * (bullet_y < obj_y + obj_height) {
            if obj_id == SAVE_BLOCK_ID {
                set_kid_checkpoint(obj_x, obj_y)
            }
            set(bullet_directions+bullet_index, 0)
            bullet_count = bullet_count - 1  // Delete bullet
            break
        }
    }

}


fn move_bullets() {
    for (let i = 0; i < MAX_BULLETS; i = i + 1) {
        let bullet_dir = get(bullet_directions+i)
        if bullet_dir == 0 {
            continue
        }

        let pixel_buffer_pointer = bullet_pixel_buffer+i*BULLET_AREA

        let bullet_x = get(bullet_positions_x+i)
        let bullet_y = get(bullet_positions_y+i)

        paste_screen_region(
            pixel_buffer_pointer,
            bullet_x / COORD_SCALE, bullet_y / COORD_SCALE,
            BULLET_PIXEL_SIZE, BULLET_PIXEL_SIZE
        )

        let new_bullet_x = bullet_x + BULLET_SPEED * DELTA * bullet_dir
        if (new_bullet_x < 0) + (new_bullet_x > WIDTH * COORD_SCALE) {
            // Bullet went off screen; delete
            set(bullet_directions+i, 0)
            bullet_count = bullet_count - 1
            continue
        }
        else {
            collide_bullet(i, new_bullet_x, bullet_y)
        }
        set(bullet_positions_x+i, new_bullet_x)
        copy_screen_region(
            pixel_buffer_pointer,
            new_bullet_x / COORD_SCALE, bullet_y / COORD_SCALE,
            BULLET_PIXEL_SIZE, BULLET_PIXEL_SIZE
        )

    }
}


fn draw_bullets() {
    for (let i = 0; i < MAX_BULLETS; i = i + 1) {
        let bullet_dir = get(bullet_directions+i)
        if bullet_dir == 0 {
            continue
        }

        let bullet_x = get(bullet_positions_x+i) / COORD_SCALE
        let bullet_y = get(bullet_positions_y+i) / COORD_SCALE

        draw_texture(
            SPRITE_BULLET,
            bullet_x, bullet_y
        )
    }
}


fn save_block_tick() {
    if hit_save_block_timer > 0 {
        hit_save_block_timer = hit_save_block_timer - DELTA
        if hit_save_block_timer <= 0 {
            draw_level_object(SAVE_BLOCK_ID, hit_save_block_x, hit_save_block_y, 1, 1)
            hit_save_block_timer = 0
        }
    }
}


fn next_level_tick() {
    let level_change = 0
    let direction = -1
    if kid_y + KID_HEIGHT < 0 {
        direction = ENUM_UP
    }
    else if kid_x > WIDTH * COORD_SCALE {
        direction = ENUM_RIGHT
    }
    else if kid_y > HEIGHT * COORD_SCALE {
        direction = ENUM_DOWN
    }
    else if kid_x + KID_WIDTH < 0 {
        direction = ENUM_LEFT
    }

    if direction != -1 {
        level_change = -(prev_level_direction == direction) + (next_level_direction == direction)    
        if level_change {
            current_level = current_level + level_change
            load_current_level(direction)
            check_finish_game()
            copy_kid_pixels()
        }
    }
}


fn reset_tick() {
    if CONTROL1 * !prev_CONTROL1 {
        // Toggle debug mode
        if CONTROL2 * LEFT * RIGHT {
            debug_mode_enabled = !debug_mode_enabled
        }

        paste_kid_pixels()
        death_counter = death_counter + 1
        kid_is_dead = false
        kid_x = kid_save_x
        kid_y = kid_save_y
        kid_vx = 0
        kid_vy = 0
        kid_jump_counter = 0
        current_level = kid_save_level
        load_current_level(-1)
        copy_kid_pixels()
    }
    let prev_CONTROL1 = CONTROL1
}


fn draw_kid() {
    if debug_mode_enabled {
        color(0, 0, 255)
        outline_rect(kid_x / COORD_SCALE+1, kid_y / COORD_SCALE+1, KID_PIXEL_WIDTH-2, KID_PIXEL_HEIGHT-2)
    }

    kid_anim_timer = (kid_anim_timer + DELTA) % (kid_anim_frames * kid_anim_frame_interval)
    let current_frame_x = kid_anim_timer / kid_anim_frame_interval * KID_PIXEL_WIDTH
    draw_texture_region(
        kid_anim_ss,
        kid_x / COORD_SCALE, kid_y / COORD_SCALE,
        current_frame_x, 0, KID_PIXEL_WIDTH, KID_PIXEL_HEIGHT, 
        kid_facing_left
    )
}


fn check_finish_game() {
    if current_level == ENDING_LEVEL {
        game_is_finished = true

        let time_string = "Time: %i:%s.%s"
        let deaths_string = "Deaths: %i"

        let deaths_string_formatted[32]
        let time_string_formatted[32]
        let zero_pad_buffer[6]

        let time_us = game_timer * 1667
        let minutes = time_us / (60000 * TIME_SCALE)
        time_us = time_us % (60000 * TIME_SCALE)
        let seconds = time_us / (1000 * TIME_SCALE)
        let ms = time_us % (1000 * TIME_SCALE) / TIME_SCALE
        format(time_string_formatted, time_string, minutes)

        // Add padding zeros to seconds and milliseconds
        let seconds_buffer = zero_pad_buffer+1
        int_to_str(seconds_buffer, seconds)
        if seconds < 10 {
            seconds_buffer = seconds_buffer-1
            set(seconds_buffer, 2)
            set(seconds_buffer+1, ZERO_CHAR)
        }
        format(time_string_formatted, time_string_formatted, seconds_buffer)

        let ms_buffer = zero_pad_buffer+2
        int_to_str(ms_buffer, ms)
        if ms < 10 {
            ms_buffer = ms_buffer-2
            set(ms_buffer, 3)
            set(ms_buffer+1, ZERO_CHAR)
            set(ms_buffer+2, ZERO_CHAR)
        }
        else if ms < 100 {
            ms_buffer = ms_buffer-1
            set(ms_buffer, 3)
            set(ms_buffer+1, ZERO_CHAR)
        }
        format(time_string_formatted, time_string_formatted, ms_buffer)

        format(deaths_string_formatted, deaths_string, death_counter)

        draw_shadow_text(time_string_formatted, 620, 20, 2, TEXT_ALIGN_RIGHT, 2)
        draw_shadow_text(deaths_string_formatted, 620, 50, 2, TEXT_ALIGN_RIGHT, 2)
    }
}